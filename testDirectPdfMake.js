const _=global
//ignoreAllByLibal
//libalCodingHelper
//Sheba
//labDepartment

/**
 * Direct pdfmake Hebrew Test - Skip HTML conversion
 * Use pdfmake directly with Hebrew text
 */

async function main(context) {
    const { ColorLog, pdfMake, moment, fsExtra } = context;
    
    ColorLog.BW('üöÄ Direct pdfmake Hebrew Test');
    ColorLog.BW('=============================');
    
    try {
        if (!pdfMake) {
            ColorLog.RW('‚ùå pdfMake not available');
            return { success: false, error: 'pdfMake not available' };
        }
        
        ColorLog.GW('‚úÖ pdfMake available');
        
        // Create document definition with Hebrew text
        const docDefinition = {
            info: {
                title: 'Hebrew PDF Test',
                author: 'RunCodeV3',
                subject: 'Direct Hebrew Text Test'
            },
            content: [
                {
                    text: 'Hebrew PDF Test - ◊ë◊ì◊ô◊ß◊™ PDF ◊ë◊¢◊ë◊®◊ô◊™',
                    style: 'header',
                    alignment: 'right'
                },
                {
                    text: '========================',
                    alignment: 'center',
                    margin: [0, 0, 0, 20]
                },
                {
                    text: '◊©◊ú◊ï◊ù ◊¢◊ï◊ú◊ù - ◊ñ◊î◊ï ◊û◊ë◊ó◊ü ◊ú◊ô◊¶◊ô◊®◊™ PDF ◊ë◊¢◊ë◊®◊ô◊™',
                    alignment: 'right',
                    margin: [0, 0, 0, 10]
                },
                {
                    text: `◊™◊ê◊®◊ô◊ö: ${moment().format('DD/MM/YYYY')}`,
                    alignment: 'right',
                    margin: [0, 0, 0, 10]
                },
                {
                    text: `◊©◊¢◊î: ${moment().format('HH:mm:ss')}`,
                    alignment: 'right',
                    margin: [0, 0, 0, 10]
                },
                {
                    text: '◊ê◊ï◊™◊ô◊ï◊™ ◊¢◊ë◊®◊ô◊ï◊™: ◊ê◊ë◊í◊ì◊î◊ï◊ñ◊ó◊ò◊ô◊õ◊ú◊û◊†◊°◊¢◊§◊¶◊ß◊®◊©◊™',
                    alignment: 'right',
                    margin: [0, 0, 0, 10]
                },
                {
                    text: '◊û◊°◊§◊®◊ô◊ù: 1234567890',
                    alignment: 'right',
                    margin: [0, 0, 0, 10]
                },
                {
                    text: 'English + ◊¢◊ë◊®◊ô◊™ mixed text',
                    alignment: 'left',
                    margin: [0, 0, 0, 10]
                },
                {
                    text: [
                        'Platform: ',
                        { text: process.platform, bold: true },
                        '\nNode Version: ',
                        { text: process.version, bold: true },
                        '\nGenerated by: RunCodeV3'
                    ],
                    margin: [0, 20, 0, 0]
                }
            ],
            styles: {
                header: {
                    fontSize: 18,
                    bold: true
                }
            },
            defaultStyle: {
                fontSize: 12,
                lineHeight: 1.3
            }
        };
        
        ColorLog.BW('üìÑ Creating PDF with pdfmake...');
        
        // Generate filename
        const filename = `direct_hebrew_${moment().format('YYYYMMDD_HHmmss')}.pdf`;
        
        try {
            // Initialize pdfmake with fonts
            const PdfPrinter = pdfMake;
            const printer = new PdfPrinter({
                Roboto: {
                    normal: 'Helvetica',
                    bold: 'Helvetica-Bold',
                    italics: 'Helvetica-Oblique',
                    bolditalics: 'Helvetica-BoldOblique'
                }
            });
            
            // Create PDF document
            const pdfDoc = printer.createPdfKitDocument(docDefinition);
            
            // Get buffer from PDFKit document
            const chunks = [];
            pdfDoc.on('data', chunks.push.bind(chunks));
            const buffer = await new Promise((resolve, reject) => {
                pdfDoc.on('end', () => {
                    resolve(Buffer.concat(chunks));
                });
                pdfDoc.on('error', reject);
                pdfDoc.end();
            });
            
            // Save to file
            await fsExtra.writeFile(filename, buffer);
            
            // Check file stats
            const stats = await fsExtra.stat(filename);
            
            ColorLog.GW(`‚úÖ Direct Hebrew PDF generated: ${filename}`);
            ColorLog.GW(`üìä Size: ${stats.size} bytes`);
            ColorLog.YB('üìã Check PDF to see if Hebrew displays correctly with right alignment');
            
            return {
                success: true,
                filename: filename,
                size: stats.size,
                method: 'Direct pdfmake with Hebrew'
            };
            
        } catch (pdfError) {
            ColorLog.RW('‚ùå PDF generation error:', pdfError.message);
            throw pdfError;
        }
        
    } catch (error) {
        ColorLog.RW('‚ùå Direct pdfmake test failed:', error.message);
        return { success: false, error: error.message };
    }
}